---
layout: default
title: Outline
parent: Software Engineering
mathjax: true
---

# Unit 1 - software development life cycle

- software vs program
  - program is simple and usually a single source code file
  - software is a complex piece where more than one program are combined
- characteristics/features of a software
  - functionality - does it do what it was made for
  - reliability - how many times it break
  - usability - how much easier it is to use, learning curve
  - efficiency - how much resources it use
  - maintainability - how much it is easier to add feature of a fix
  - portability - can it run on multiple platforms
- software crisis
  - why it occurred?
    - increasing demand
    - increasing complexity
    - increasing challenges
    - same workforce
    - same methods
    - same tools
  - consequences?
    - project running over budget
    - project running over time
    - software very inefficient
    - projects were unmanageable and code difficult to maintain
    - software of low quality
    - the software often did not meet requirements
- types of software
  - system
  - application
  - scientific engineering
  - embedded
  - web 
  - ai
  - networking
  - business
  - entertainment
  - utility
  - document management
  - reservation

- software development life cycle
  - used by software industry to design, develop and test high quality software.
- models
  - code and fix
  - waterfall model
  - iterative waterfall model
  - V-model
  - evolutionary model
    - incremental implementation
    - prototyping
      - throwaway
      - evolutionary
  - spiral
  - software reuse
- comparing sdlc models
  - factors
    - shortfall - a measure how far the software is from meeting user requirements
    - lateness - time delay between appearance of new requirement and its fulfillment
    - adaptability - rate at which software can adapt to new requirements
    - longevity - time form system creation till its replacement
    - inappropriateness - measure of behavior of shortfall over time

- non traditional software development process
  - rapid application development (RAD)
    - business modeling
    - data modelling
    - process modelling
    - application generation
    - testing and turnover
  - rational unified process
    - inception
    - elaboration
    - construction
    - transition
  - agile development process
    - extreme programming (XP)
    - SCRUM

# Unit 2 - requirements

- requirements
  - types
    - system
    - user
    - functional 
    - non functional
      - product
      - organizational
      - external
- requirement engineering process
  - feasibility study
    - technical
    - operational
    - legal
    - schedule
  - requirement elicitation and analysis
    - process
      - requirement discovery
      - requirement classification and organization
      - requirement prioritization and negotiation
      - requirement specification
    - techniques
      - interviewing
      - observation
      - scenarios
      - use cases
      - questionnaires
      - survey
      - existing manual
      - group discussion
      - prototyping
      - brainstorming
  - requirement specification
    - how to write (specification)
      - natural language
      - structured
      - graphical notation
        - uml
      - mathematical
      - srs standards - ieee
        - good srs
          - correctness
          - completeness
          - consistency
          - concise
          - structured
          - unambiguous
          - verifiable
          - modifiable
          - traceable
          - testable
  - requirement verification and validation
    - validation checks
      - validity - 
      - consistency - requirements should not conflict
      - completeness 
      - realism - can sol. be implemented within time and available check
      - verifiability - can we write test to demonstrate that software meet srs
  - requirement management
- tools for requirement gathering
  - decision tables
    - condition entities
    - action entities
  - decision tree
  - data flow diagrams
    - made of
      - data flow - arrow
      - data transform or process - circle
      - data store - box open at one end
      - external entity - rectangle
    - level0
    - level1
    - level2
  - data dictionaries

# Unit 3 - software design

- Software design
- activities
  - high level design 
  - detailed design
- good software design
  - correctness
  - understandability
  - efficiency
  - maintainability
  - completeness
  - consistency
- principles
  - problem partitioning
  - increasing abstraction
  - modularity
  - increase cohesion
  - reduce coupling
  - increase reusability
  - design for flexibility - should be flexible to anticipate changes
  - design for portability
  - design for testability
- level oriented software design
  - bottom up
  - top down
- function and object oriented software design
  - er model
  - decision tree
  - dfd
    - 0 level - context diagram
    - 1 level
    - 2 level
  - structure charts
- cohesion
  - coincidental - randomly put together
  - logical - similar functions
  - temporal - functions executed at same period
  - procedural - working for same algo and goal
  - communicational - all function refer to or update same data structure
  - sequential - elements are part of a sequence
  - functional - all elements work together to achieve a single task
- coupling
  - data - communicate through a parameter - int bool
  - stamp - through a c like structure
  - control - data from one is used to direct the order in another
  - common - global items
  - content - they share code
- functional independence
  - error isolation
  - scope of reuse
  - understandability

- object oriented design (ood)
  - class
  - abstraction
  - encapsulation
  - inheritance
  - polymorphism
- UML in ood
  - things - class, object, interface
  - relationships - 
  - diagrams
  - structural diagram - class diagrams show object classes and associations between them
  - interaction diagram - show interactions
  - behavioral diagrams - activity diagrams which show activities involved in process of data
- Context Models
- Interaction Models
  - use case diagram
  - sequence diagram
- Structured Models
  - class diagrams
- Behavioral Diagrams
  - data drive modelling
    - activity diagram
  - event driven modelling

- Architectural Design
- Architectural Views
  - logical view
  - process view
  - development view
  - physical view
- Architectural Patterns 
  - Layered
  - Repository
  - Client-server
  - Pipe-filter

- Development
  - Selection of a language
  - Reuse of the software
  - Configuration management
    - Version management
    - System integration
    - Problem tracking
  - Host target development
- Coding
- Coding guidelines
  - small and easy to understand
  - module - date of creation, who creates, use
  - naming convention
  - no goto
  - code documentation
- Coding Documentation
  - README
  - functionality of each module
  - naming conventions
  - name of contributors
  - license and version
- Code Review
  - code walkthrough
  - code inspection


# Unit 4 - testing

- bugs - defect informally
- defect - system not meeting the requirement
- error - mistake in code is called error
- fault - the state of incorect working of a system
- failure - when multiple defects occur

- Intro
  - Testing Objectives
    - validation testing
    - defect testing - where srs is not met
  - verification vs validation
    - vefification 
      - srs, design, and code are checked
      - may not include program execution
      - code inspection, reviews, walkthroughs
    - validation
      - done in the end
      - generic process that is used to endure srs is met
  - Software Insepection
- Testing Process
  - Development Testing
    - Unit Testing
      - Test Case generation
        - Partition testing - equivalence classes
        - guideline based testing - based on experience
    - Integration Testing
      - big bang integraiton testing
      - Top down integration testing
      - bottom up integration testing
      - sandwitch integration testing
  - Release Testing of functionality testing
    - requirement based testing - based on srs
    - scenario testing - bases on real world scenarios
    - performace testing
      - stress testing - light load - high load
      - volume testing - data structures used are tested for overflow
      - configuration testing - configutation of hardware and software is verified
      - compatibality testing - compatibility between hardware, os, browser
      - recovery testing - system respoonse to faults, loss of service such as power
      - maintainance testing - testing performed on alresdy installed system
      - documentation testing - 
      - usability testing - user interface is tested
      - regression testing - testing when an existing system is changed orr upgraded
        if there are new bugs after additon of new features or performace issues
  - User Testing or System Testing
    - alpha testing
      - tesing team and developers
    - beta testing
      - friendly customers
    - acceptance testing
      - end user test the system and decide whether the system is ready for deployment
- Structural and functional testing
  - structural testing - **white box, clear box**
    - test code, code specification, input output constrians, data structure
  - functional testing **black box testing**
    - check srs
  - White box testing 
    - statement coverage testing
      - test cases are such that every statement should be executes once
    - Branch Coverage testing
      - test cases are such that every branch should be executed once
      - stronger than statement
    - Condition testing
      - each expression is tested
      - $2^n$ test case required
      - used when n is small
    - Path testing - used control flow graph (CFG)
      - path are tested which are linear independent
      - **Cyclometric complexity**
        - method 1: $C(G) = E-V+2$
        - method 2: total no of bounded areas + 1
        - method 3: total no of decision statement + 1, also called **McCabe's meric**
    - Mutation Testing
      - change some code randomly and check if errors are generated by the 
        test cases
  - **Black Block Testing** or behavioural testing
    - test input and output
    - stratigies
      - use equivalence classes
      - boundary value testing
      - decision table testing
- Static Testing Stratigies
  - missing requirements, inconsistencies in interface desing, deviation form target problem
  - no execution of code
  - Review
    - informal
    - walk through
    - peer review - team member check each other code
    - insepection - srs used to verify the code by higher authorities
  - static analysis
    - quality of developed code evaluated
    - defect - syntax error, variable that is not used, unwanted code, infinte loop
    - test used
      - data flow checking
      - control folw
      - identification of linearlty independent paths
- Automated testing
  - using test suite
  - not cost effective
  - when to use
    - critical software high risk, 
    - repeated execution of test cases
    - lengthy codewith high volume

# Unit 5 - project management and mamagement

- COCOMO Constructive Cost Model
  - $\text{effort} = a_1 * (\text{KLOC})^{a_2} \text{ PM}$
  - $\text{time}_{dev} = b_1 * (\text{effort})^{b_2} \text{ months}$
- ISO 9000 standard
  - guidelines for producing the product
  - not concerned with teh product itself
  - types
    - 9001 - applies to most software organizations
    - 9002 - standard focus on manufacturing not for software products
    - 9003 - organizations involved only in installation and testing ofd products
  - iso cerification - customer gets confidence in product
  - does not gaurantee the high quality of the process
  - heavy emphasis on documentation and take lot of time and effort
- SEI CMM - software engineering institute capibility maturity model

# analytical estimation

- $\eta_1$ no of unique operation
- $\eta_2$ no of unique operands
- $N_1$ no of operators
- $N_2$ no of operands
- $N = N_1 + N_2$ - length of code
- $\eta = \eta_1 + \eta_2$ vocabulary of code
- $V = N \log_{2}{\eta}$ - volume of the code
- $V^*  = (2+\eta_2) \log_2{(2+\eta_2)}$ - potential minimal volume
- $L = V^*/V$ - program level - level of abstraction
- $E = V/L = V^2/V^*$ - effort
- $T = E/S$ - time, S - speed of mental discrimination
- $N = \eta_1 \log_2{\eta_1} + \eta_2 + \log_2{\eta_2}$ - length estimation